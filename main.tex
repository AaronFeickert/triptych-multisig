\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{hyperref}
\usepackage[symbol]{footmisc}

\newcommand{\F}{\mathbb{F}}
\newcommand{\G}{\mathbb{G}}
\newcommand{\hs}{\mathcal{H}}
\newcommand{\enc}{\operatorname{Enc}}
\newcommand{\dec}{\operatorname{Dec}}

\title{Triptych multisignature analysis}
\author{Cypher Stack}
\date{\today}

\begin{document}

\maketitle

This document describes research and analysis into multisignature support for the Triptych zero-knowledge proving system and its associated transaction model.

\textbf{All material in this document should be considered experimental and unsuitable for production without thorough independent review.}


\section{Introduction}

Triptych \cite{triptych} is a zero-knowledge proving system that can be used in a multidimensional linkable ring signature construction to build a confidential transaction protocol.
Proofs constructed using Triptych scale in size logarithmically with the size of the input anonymity set, and can take advantage of efficient verification using batching and multiscalar multiplication.

A currently open question is the extent to which the protocol can support multisignature operations, where a group of players each holding a portion of a private signing key can jointly produce a valid transaction without mutual trust in each other or another third party.
It is a requirement that the resulting proof be indistinguishable from one produced by a single player holding a private key; that is, the resulting proof must be verifiable using a standard public key.

A confidential protocol based on Triptych requires the use of a private key in two places: during generation of a one-of-many authorizing proof, and when constructing a linking tag used to prevent double-spend attempts.
The one-of-many proof uses the private key in a linear fashion, which allows for straightforward approaches to multiparty computation.
However, the linking tag is constructed using the inverse of the private key, posing a challenge to such operations.
Fortunately, this inversion operation is similar to that used in other protocols, so we can apply earlier work toward a solution.

Let $\G$ be the prime-order subgroup of the \texttt{ed25519} elliptic curve group, and let $\F$ be its scalar field.
Let $G$, $H$, and $U$ be independent fixed generators of $\G$ known to all players.
Let $\hs: \{0,1\}^* \to \F$ be a cryptographic hash function.
We often prefix input to $\hs$ with an integer value, to act as an arbitrary domain separator; note that any equivalent domain separation method may be substituted, and that our notation is used for convenience.
When referring to sets of keys generated by players, we assume a fixed and publicly-known ordering, such as lexicographic ordering, is used.


\section{Key generation}

Keys are generated in a manner similar to that of MuSig \cite{musig}.
We assume a set of $\nu$ players who wish to generate linear shares of a private and public key constructed in the following way.
Throughout this section, we assume actions taken by a player $\alpha \in [0,\nu)$ are separately taken by all $\nu$ players in parallel.
\begin{enumerate}
    \item Each player $\alpha$ chooses random $(a_\alpha, b_\alpha) \in \F^2$ and computes $B_\alpha \equiv b_\alpha G$.
    It generates a private key $\gamma_\alpha$ and corresponding public key $\Gamma_\alpha$ for the Paillier cryptosystem compatible with encryption of \texttt{ed25519} prime-order subgroup scalar elements.
    It sends the tuple $(a_\alpha, B_\alpha, \Gamma_\alpha)$ to all players.
    \item Each player $\alpha$ computes the aggregate private view key $$a \equiv \sum_{\alpha=0}^{\nu-1} \hs(0, \{a_\beta G\}_{\beta=0}^{\nu-1}, \alpha) a_\alpha$$ and corresponding aggregate public view key $$A \equiv aG = \sum_{\alpha=0}^{\nu-1} \hs(0, \{a_\beta G\}_{\beta=0}^{\nu-1}, \alpha) a_\alpha G.$$
    \item Each player $\alpha$ computes the aggregate public spend key $$B \equiv \sum_{\alpha=0}^{\nu-1} \hs(1, \{B_\beta\}_{\beta=0}^{\nu-1}, \alpha) B_\alpha.$$
\end{enumerate}

The aggregate public key pair $(A,B)$ is used to receive transactions.


\section{Transaction generation and scanning}

A sender produces a transaction for the address $(A,B)$ as usual; we describe the process here for the sake of notation clarity.
\begin{enumerate}
    \item The sender chooses random $r \in \F$ and sets $R \equiv rG$.
    \item The sender computes the output public key $P \equiv \hs(2,rA)G + B$.
    \item The sender chooses random $s_1 \in \F$ and, using a valid value $v \in \F$, computes a commitment $C_{\operatorname{val}} \equiv s_1 G + vH$.
    \item The sender computes other auxiliary transaction information as needed.
\end{enumerate}

The sender includes $R, P, C_{\operatorname{val}}$ among other public transaction information, and submits the transaction to the network.

Any of the $\nu$ players holding shares of the address $(A,B)$ scan transactions for outputs destined for the address as usual, using the known aggregate private view key $a$ and aggregate public spend key $B$.
Specifically, for a given output public key $P$ with associated $R$, they test if $\hs(2,aR)G + B = P$, and ignore if the equality does not hold.
If it does, we note the associated private key:
\begin{align*}
p &\equiv \hs(2,aR) + b \\
&= \hs(2,aR) + \sum_{\alpha=0}^{\nu-1} \hs(1, \{B_\beta\}_{\beta=0}^{\nu-1}, \alpha) b_\alpha
\end{align*}
Of course, each player $\alpha$ holds only its own share $b_\alpha$ of the aggregate private spend key.


\section{Linking tag computation}

To spend the output represented by the public output key $P$, the players must cooperatively compute the associated linking tag $J$.
In the Triptych protocol, this tag is defined (continuing our rather bespoke notation from this documentation, rather than directly using the notation from \cite{triptych}) as follows:
\begin{align*}
J &\equiv p^{-1}U \\
&= \left( \hs(2,aR) + \sum_{\alpha=0}^{\nu-1} \hs(1, \{B_\beta\}_{\beta=0}^{\nu-1}, \alpha) b_\alpha \right)^{-1}U
\end{align*}

The non-linearity of the linking tag with respect to the associated output private key makes such a cooperative computation more complex.
However, we can apply a method of Gennaro and Goldfeder \cite{gennaro}, which was originally devised for use in multiparty threshold ECDSA signature computation.
The result will be that all players obtain $J$ without revealing their private spend key shares to each other.

Because $p$ consists of an additive prefix $\hs(2,aR)$ that is not distributed between players, we define players' secret shares $\{p_\alpha\}_{\alpha=0}^{\nu-1}$ of $p$ according to their index:
\begin{itemize}
    \item $p_0 := \hs(2,aR) + \hs(1, \{B_\beta\}_{\beta=0}^{\nu-1}, 1) b_1$
    \item $p_{\alpha > 0} := \hs(1, \{B_\beta\}_{\beta=0}^{\nu-1}, \alpha) b_\alpha$
\end{itemize}
The result is that $\sum_{\alpha=0}^{\nu-1} p_\alpha = p$.
The designation of indices does not affect protocol security.

A more comprehensive version of this method assumes the use of range proofs coupled with Paillier ciphertext; however, the authors hypothesize (but do not prove) that no significant information leakage occurs if these proofs are omitted.

We specifically require the use of Paillier public-key encryption, the keys for which have been introduced previously.
Let $\enc_\alpha$ represent Paillier encryption using the public key $\Gamma_\alpha$ for player $\alpha$, and $\dec_\alpha$ represent Paillier decryption using the private key $\gamma_\alpha$ for this player.

The process proceeds as follows.
\begin{enumerate}
    \item Each player $\alpha$ chooses random $g_\alpha \in \F$ and sets $G_\alpha \equiv g_\alpha U$.
    It generates a commitment $C_{\operatorname{tag},\alpha}$ to $G_i$ and sends the commitment to all players.
    \item Each player $\alpha$ sets $c_\alpha \equiv \enc_\alpha(p_i)$. It sends $c_\alpha$ to all players.
    \item For each other player $\beta$, player $\alpha$ chooses random $b_{\alpha\beta} \in \F$.
    It sends the value $\gamma_\alpha c_\beta + \enc_\beta(-b_{\alpha\beta})$ to player $\beta$, who decrypts using $\gamma_\beta$ and defines $a_{\beta\alpha}$ to be the resulting plaintext.
    \item Each player $\alpha$ computes $\delta_\alpha := p_\alpha \gamma_\alpha + \sum_{\beta \neq \alpha}(a_{\alpha\beta} + b_{\alpha\beta})$.
    It computes a Schnorr proof of representation $\Pi_\alpha$ of $G_\alpha$ with respect to the generator $U$.
    It sends $G_\alpha$, $\Pi_\alpha$, and $\delta_\alpha$ to all players.
    \item Each player computes $\delta := \sum_{\beta=0}^{\nu-1} \delta_\beta$.
    It ensures that the commitment $C_{\operatorname{tag},\beta}$ and Schnorr proof $\Pi_\beta$ are valid for each $\beta$, and aborts otherwise.
    It then computes the aggregate linking tag $J := \delta^{-1} \sum_{\beta=0}^{\nu-1} G_\beta$.
\end{enumerate}

Note that in this protocol, we use additive notation on Paillier ciphertexts, and multiplicative notation between field elements in $\F$ and Paillier ciphertexts.
Because of Paillier encryption homomorphism, these operations are well defined.


\section{Authorizing proof}

Triptych requires the use of a one-of-many authorizing proof.
When embedded with a linking tag and message using the non-interactive Fiat-Shamir heuristic, this proof serves as a digital signature that the signer knows the private key corresponding to an input key and corresponding to the linking tag.
The proof effectively proceeds in two stages.
In the first stage, the signer hides the index corresponding to the known public key in the input set.
In the second stage, the signer demonstrates knowledge of the private key corresponding to the public key at the hidden index, and further shows that the linking tag is constructed correctly.
Throughout this section, we assume the input set contains $N$ key tuples, where $N = n^m$ for some $n,m \in \mathbb{N}$.

The proof proceeds as follows.
\begin{enumerate}
    \item Any designated player assembles an input set $\{(M_{i,0}, M_{i,1})\}_{i=0}^{N-1}$.
    A secret index $0 \leq \ell < N$ is chosen. Each $M_{i,0} \in \G$ is an existing output public key, and the designated output public key is set such that $M_{\ell,0} = P$.
    \item Any designated player computes a commitment offset $C_{\operatorname{off}} \equiv s_2 G + vH$, where $s_2 \in \F$ is chosen according to the transaction protocol as usual.
    Each $M_{i,1}$ is the amount commitment corresponding to $M_{i,0}$, offset by $C_{\operatorname{off}}$.
    Let $s \equiv s_1 - s_2$, such that $M_{\ell,1} = sG$.
    \item Each player $\alpha$ selects random $$r_A^{(\alpha)}, r_B^{(\alpha)}, r_C^{(\alpha)}, r_D^{(\alpha)}, \left\{a_{j,i}^{(\alpha)}\right\}_{i=1,j=0}^{n-1,m-1}, \left\{\rho_j^{(\alpha)}\right\}_{j=0}^{m-1} \in \F$$ according to the proof protocol.
    It sends the values $$r_A^{(\alpha)}, r_B^{(\alpha)}, r_C^{(\alpha)}, r_D^{(\alpha)}, \left\{a_{j,i}^{(\alpha)}\right\}_{i=1,j=0}^{n-1,m-1}, \left\{\rho_j^{(\alpha)}G\right\}_{j=0}^{m-1}, \left\{\rho_j^{(\alpha)}J\right\}_{j=0}^{m-1}$$ to all players.
    \item Each player computes the following values:
        \begin{align*}
            r_A &\equiv \sum_{\alpha=0}^{\nu-1} \hs(3, \{r_A^{(\beta)}\}_{\beta=0}^{\nu-1}, \alpha) r_A^{(\alpha)} \\
            r_B &\equiv \sum_{\alpha=0}^{\nu-1} \hs(4, \{r_B^{(\beta)}\}_{\beta=0}^{\nu-1}, \alpha) r_B^{(\alpha)} \\
            r_C &\equiv \sum_{\alpha=0}^{\nu-1} \hs(5, \{r_C^{(\beta)}\}_{\beta=0}^{\nu-1}, \alpha) r_C^{(\alpha)} \\
            r_D &\equiv \sum_{\alpha=0}^{\nu-1} \hs(6, \{r_D^{(\beta)}\}_{\beta=0}^{\nu-1}, \alpha) r_D^{(\alpha)} \\
            \left\{a_{j,i}\right\}_{i=1,j=0}^{n-1,m-1} &\equiv \left\{\sum_{\alpha=0}^{\nu-1} \hs(7, \{a_{j,i}^{(\beta)}\}_{\beta=0}^{\nu-1}, \alpha) a_{j,i}^{(\alpha)}\right\}_{i=1,j=0}^{n-1,m-1} \\
            \{\rho_j G\}_{j=0}^{m-1} &\equiv \left\{\sum_{\alpha=0}^{\nu-1} \hs(8, \{\rho_j^{(\beta)}G, \rho_j^{(\beta)}J\}_{\beta=0}^{\nu-1}, \alpha) \rho_j^{(\alpha)}G\right\}_{j=0}^{m-1} \\
            \{\rho_j J\}_{j=0}^{m-1} &\equiv \left\{\sum_{\alpha=0}^{\nu-1} \hs(8, \{\rho_j^{(\beta)}G, \rho_j^{(\beta)}J\}_{\beta=0}^{\nu-1}, \alpha) \rho_j^{(\alpha)}J\right\}_{j=0}^{m-1}
        \end{align*}
        It uses the index $\ell$ to compute the set $\{\sigma_{j,i}\}_{i,j=0}^{n-1,m-1}$ according to the proof protocol, and further uses this collection of values to compute $A, B, C, D$ as well.
    \item Each player computes the hash value $\mu$, the values $\{X_j,Y_j\}_{j=0}^{m-1}$, and the challenge $\xi$ according to the proof protocol.
    It computes the set $\{f_{j,i}\}_{i=1,j=0}^{n-1,m-1}$ and the values $z_A, z_C, K$.
    \item Each player $\alpha$ computes $$z^{(\alpha)} \equiv \hs(1, \{B_\beta\}_{\beta=0}^{\nu-1},\alpha) b_\alpha \xi^m - \sum_{j=0}^{m-1} \hs(8, \{\rho_j^{(\beta)}G, \rho_j^{(\beta)}J\}_{\beta=0}^{\nu-1}, \alpha) \rho_j^{(\alpha)}\xi^j$$ and sends this value to all players.
    \item Each player computes $$z \equiv (\hs(2, aR) + \mu s)\xi^m + \sum_{\alpha=0}^{\nu-1} z^{(\alpha)}$$ and assembles the complete proof.
\end{enumerate}


\section{Observations}

A possible modification is to replace the Schnorr proof of representation of the value $G_\alpha$ in the Paillier inversion protocol with a proof that the associated commitment $C_{\operatorname{tag},\alpha}$ has a known discrete logarithm.

It may be necessary to require a specific commitment round for the authorizing proof pre-challenge values.
Currently, these values are computed using MuSig-type hash aggregation in order to assert that the resulting aggregated values are uniformly distributed and cannot be controlled by malicious players.
However, the aggregation uses a common coefficient set to compute values of the form $\{\rho_j G\}$ and $\{\rho_j J\}$.

It may be secure in practice to compress the Paillier inversion protocol, sending the initial commitment and encrypted key shares simultaneously.


\section{Conclusions}

The use of cooperative signing in the Triptych transaction protocol imposes significant communication complexity.
Notably, the inversion construction of linking tags requires an expensive many-to-many share conversion that itself requires multiple communication rounds between all signers, and a Paillier-based approach to this inversion itself requires support for arbitrary RSA groups.

Because security of the authorizing proof relies in part on Fiat-Shamir transcripts, signers cannot complete this proof (namely, the challenge values) without first computing the corresponding linking tag, as the tag must be embedded in the transcript.
Further, it is not possible to complete the entire pre-challenge portion of the authorizing proof prior to the linking tag computation, as this also requires knowledge of the complete tag.

If efficient multisignature operations are a priority for which this level of communication complexity is infeasible, it may be beneficial to investigate alternate transaction protocols that use linear linking tag constructions and/or simpler cooperative authorization proofs.
The author is aware of (and collaborating on the development of) at least two newer trustless protocols that take this approach: Seraphis\footnote{\url{https://gist.github.com/UkoeHB/24f6be6125684046c5c4d9f49351bccf}} and Lelantus 3\footnote{Disclaimer: The Firo project funds Cypher Stack research that includes development of this protocol.}.

It remains for stakeholders and interested parties to assess the feasibility of this construction as it applies to protocols of interest, and determine if Cypher Stack or other researchers and developers should continue to formalize, optimize, implement, or deploy it in software.


\bibliographystyle{plain}
\bibliography{main}

\end{document}
